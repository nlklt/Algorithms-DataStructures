# LIS — непрерывно возрастающая последовательность

> Реализация **двух** подходов для поиска наибольшей возрастающей подпоследовательности (LIS).  

---

## Кратко
- Реализовано: `getLIS_n2` — классический DP с восстановлением последовательности, `getLIS_nlogn` — оптимизированный метод с `tails` + бинарным поиском, также с восстановлением.

---

## Суть алгоритмов
- **O(n²)** — для каждого i ищем лучший j < i, который принадлежит более длинной последовательности; запоминаем `parent`(индекс) для восстановления.
- **O(n·log n)** — поддерживаем `tails` индексов минимальных концов для всех длин; бинарный поиск по `tails`; `parent` для восстановления.

---

## Сложность

| Алгоритм | Время | Память | Восстановление |
|---:|:---:|:---:|:---:|
| `getLIS_n2` | O(n²) | O(n) | Да |
| `getLIS_nlogn` | O(n·log n) | O(n) | Да |

---

## Код
```cpp
// O(n^2) — dp + parent
int maxLength = 1;
int maxIndex = 0;

for (int i = 0; i < n; ++i)
{
    for (int j = 0; j < i; ++j)
    {
        // если находим элемент меньше текущего и для него LIS длиннее
        if (nums[j] < nums[i] && dp[j] + 1 > dp[i])
        {
            dp[i] = dp[j] + 1;
            parent[i] = j;
        }
    }
    // обновляем индекс и длину если нашли более длинную LIS
    if (dp[i] > maxLength)
        {
            maxLength = dp[i];
            maxIndex = i;
        }
}

// --------------------------------------------------------------------

// O(n log n) — tails + binSearch + parent
for (int i = 0; i < n; ++i)
{
    // если продолжение самой длинной цепочки
    if (tails.empty() || nums[i] > nums[tails.back()])
    {
        if (!tails.empty())
        {
            parent[i] = tails.back();
        }
        tails.push_back(i);
    }
    // ищем место для замены, т.к. нашли число меньше конечного
    else
    {
        int idx = binSearch(tails, nums, nums[i]);
        tails[idx] = i;

        // если вставили не в начало
        if (idx > 0)
        {
            parent[i] = tails[idx - 1];
        }
    }
}
